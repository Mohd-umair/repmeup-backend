const mongoose = require('mongoose');

const interactionSchema = new mongoose.Schema({
  organization: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Organization',
    required: true,
    index: true
  },
  
  // Platform information
  platform: {
    type: String,
    enum: ['instagram', 'facebook', 'whatsapp', 'youtube', 'google', 'website'],
    required: true,
    index: true
  },
  platformConnection: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'PlatformConnection'
  },
  type: {
    type: String,
    enum: ['comment', 'dm', 'review', 'mention'],
    required: true,
    index: true
  },
  
  // Unique platform identifier
  platformId: {
    type: String,
    required: true,
    unique: true
  },
  platformUrl: String,
  
  // Content
  content: {
    type: String,
    required: true
  },
  contentType: {
    type: String,
    enum: ['text', 'image', 'video', 'audio'],
    default: 'text'
  },
  language: String,
  
  // Author information
  author: {
    platformId: String,
    name: String,
    username: String,
    email: String,
    profileUrl: String,
    avatarUrl: String,
    followerCount: Number,
    isVerified: Boolean
  },
  
  // Threading support
  parentId: String,
  threadId: String,
  hasReplies: {
    type: Boolean,
    default: false
  },
  replyCount: {
    type: Number,
    default: 0
  },
  
  // Status tracking
  status: {
    type: String,
    enum: ['unread', 'read', 'replied', 'assigned', 'resolved', 'spam', 'archived'],
    default: 'unread',
    index: true
  },
  isRead: {
    type: Boolean,
    default: false
  },
  readAt: Date,
  readBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  
  // AI & Sentiment Analysis
  sentiment: {
    type: String,
    enum: ['positive', 'negative', 'neutral'],
    index: true
  },
  sentimentScore: {
    type: Number,
    min: -1,
    max: 1
  },
  sentimentConfidence: {
    type: Number,
    min: 0,
    max: 1
  },
  topics: [String],
  intent: {
    type: String,
    enum: ['inquiry', 'complaint', 'praise', 'feedback', 'support', 'other']
  },
  urgency: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  
  // AI response
  aiSuggestion: {
    content: String,
    confidence: Number,
    generatedAt: Date,
    wasUsed: Boolean,
    feedback: {
      type: String,
      enum: ['accepted', 'modified', 'rejected']
    }
  },
  autoReplyEligible: {
    type: Boolean,
    default: false
  },
  autoReplied: {
    type: Boolean,
    default: false
  },
  
  // Assignment
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    index: true
  },
  assignedAt: Date,
  assignedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  assignmentReason: {
    type: String,
    enum: ['manual', 'auto_rule', 'escalation', 'ai_unable']
  },
  
  // Labels & categorization
  labels: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Label'
  }],
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  tags: [String],
  
  // Metadata
  metadata: {
    // For social posts
    postId: String,
    postUrl: String,
    postAuthor: String,
    
    // For reviews
    rating: {
      type: Number,
      min: 1,
      max: 5
    },
    reviewTitle: String,
    
    // Media attachments
    mediaUrls: [String],
    hasMedia: Boolean,
    
    // Location
    location: String,
    latitude: Number,
    longitude: Number,
    
    // Additional context
    deviceType: String,
    appVersion: String
  },
  
  // Response tracking
  replies: [{
    _id: {
      type: mongoose.Schema.Types.ObjectId,
      auto: true
    },
    content: String,
    sentBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    sentAt: {
      type: Date,
      default: Date.now
    },
    platformResponseId: String,
    wasAutoGenerated: {
      type: Boolean,
      default: false
    },
    usedTemplate: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'ResponseTemplate'
    },
    status: {
      type: String,
      enum: ['sent', 'failed', 'deleted'],
      default: 'sent'
    }
  }],
  
  responseCount: {
    type: Number,
    default: 0
  },
  firstResponseTime: Number, // in milliseconds
  averageResponseTime: Number,
  
  // Internal collaboration
  internalNotes: [{
    _id: {
      type: mongoose.Schema.Types.ObjectId,
      auto: true
    },
    note: String,
    addedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    addedAt: {
      type: Date,
      default: Date.now
    },
    isPrivate: {
      type: Boolean,
      default: false
    }
  }],
  
  // Engagement metrics
  engagement: {
    likes: {
      type: Number,
      default: 0
    },
    shares: {
      type: Number,
      default: 0
    },
    views: {
      type: Number,
      default: 0
    },
    replyCount: {
      type: Number,
      default: 0
    }
  },
  
  // Timestamps
  platformCreatedAt: Date,
  respondedAt: Date,
  resolvedAt: Date
}, {
  timestamps: true
});

// Indexes for performance
interactionSchema.index({ organization: 1, createdAt: -1 });
interactionSchema.index({ organization: 1, status: 1 });
interactionSchema.index({ organization: 1, platform: 1, createdAt: -1 });
interactionSchema.index({ organization: 1, sentiment: 1 });
interactionSchema.index({ assignedTo: 1, status: 1 });
interactionSchema.index({ platformId: 1 });
interactionSchema.index({ 'metadata.postId': 1 });

// Update response count when adding replies
interactionSchema.pre('save', function(next) {
  if (this.isModified('replies')) {
    this.responseCount = this.replies.length;
    
    if (this.replies.length > 0 && !this.respondedAt) {
      this.respondedAt = this.replies[0].sentAt;
      
      // Calculate first response time
      if (this.platformCreatedAt) {
        this.firstResponseTime = this.respondedAt - this.platformCreatedAt;
      }
    }
  }
  next();
});

// Method to add reply
interactionSchema.methods.addReply = function(content, userId, platformResponseId = null, wasAutoGenerated = false) {
  this.replies.push({
    content,
    sentBy: userId,
    sentAt: new Date(),
    platformResponseId,
    wasAutoGenerated
  });
  
  this.status = 'replied';
  return this.save();
};

// Method to assign to agent
interactionSchema.methods.assignTo = function(userId, assignedBy, reason = 'manual') {
  this.assignedTo = userId;
  this.assignedBy = assignedBy;
  this.assignedAt = new Date();
  this.assignmentReason = reason;
  this.status = 'assigned';
  return this.save();
};

// Method to add internal note
interactionSchema.methods.addNote = function(note, userId, isPrivate = false) {
  this.internalNotes.push({
    note,
    addedBy: userId,
    addedAt: new Date(),
    isPrivate
  });
  return this.save();
};

module.exports = mongoose.model('Interaction', interactionSchema);

